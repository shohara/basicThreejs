<title> OrbitControls Basics </title>
<body>
    <div id="container"></div>
    <script src="https://unpkg.com/three@0.147.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.147.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://unpkg.com/three@0.147.0/examples/js/geometries/ConvexGeometry.js"></script>
    <script src="https://unpkg.com/three@0.147.0/examples/js/math/ConvexHull.js"></script>
    <script src="https://unpkg.com/lil-gui@0.17.0/dist/lil-gui.umd.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        .view-container {
            display: flex;
            width: 100vw;
            height: 100vh;
        }
        .view-section {
            flex: 1;
            position: relative;
        }
        #localview {
            border-right: 2px solid #333;
        }
        #Zoom {
            position: absolute;
            top: 30px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 5px;
            border-radius: 3px;
            font-size: 12px;
        }
        .lil-gui {
            top: auto !important;
            bottom: 10px !important;
        }
    </style>
    <div class="view-container">
        <div class="view-section">
            <div id="localview">Main Camera (Perspective) 
                <div id="Zoom"></div>
            </div>
        </div>
        <div class="view-section">
            <div id="overview">Exterior View</div>
        </div>
    </div>
    <script>
        // Initial Parameters
        const initialCameraZ = 5
        var fov = 75
        var zoom = 1
        var zoomText = document.getElementById("Zoom");
        const camera = new THREE.PerspectiveCamera( fov, window.innerWidth/2 / window.innerHeight, 0.1, 1000 );
        const film35mm_w = 36
        const film35mm_h = 24
        const film35mm = (film35mm_w**2+film35mm_h**2)**0.5

        // Parameters for GUI
        const gui = new lil.GUI({ width: 200 });
		gui.open();
        const param = {
            fov: fov, // [degree]
            zoom: zoom, // [magnicification]
            showWireframe: true, // ワイヤフレーム表示/非表示
            showAxis: true // 軸表示/非表示
        }
        gui.add(param, 'fov', 1, 179).onChange(function(value) {
            fov = value
            camera.fov = fov
            camera.updateProjectionMatrix()
        });
        // gui.add(param, 'zoom', 0.1, 10).onChange(function(value) {
        //     zoom = value
        //     camera.zoom = zoom
        //     camera.updateProjectionMatrix()
        // });
        gui.add(param, 'showWireframe').onChange(function(value) {
            if (sphereWireframe) {
                sphereWireframe.visible = value;
            }
        });
        gui.add(param, 'showAxis').onChange(function(value) {
            if (axes) {
                axes.visible = value;
            }
        });

        // Utility functions
        var fov_horizontal = (f) => {
            return 2 * Math.atan(film35mm_w / 2.0 / f)
        }
        var fov_vertical = (f) => {
            return 2 * Math.atan(film35mm_h / 2.0 / f)
        }
        var fov_diag = (f) => {
            return 2 * Math.atan(film35mm / 2.0 / f)
        }

        // Create a sphere with 360 image texture
        var sphereWireframe;
        var drawSphereObject = (position, radius) => {
            const sphereGeometry = new THREE.SphereGeometry(radius, 32, 32);
            
            // 360画像のテクスチャを読み込み
            const textureLoader = new THREE.TextureLoader();
            const texture = textureLoader.load('360photo.jpg');
            
            const sphereMaterial = new THREE.MeshBasicMaterial({ 
                map: texture,
                side: THREE.BackSide // 球体の内側から見るため
            });
            const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);

            // ワイヤフレームを作成
            const edges = new THREE.EdgesGeometry(sphereGeometry);
            sphereWireframe = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0xffffff }));
            sphereWireframe.visible = param.showWireframe;

            const group = new THREE.Group();
            group.add(sphere);
            group.add(sphereWireframe);

            group.position.x = position.x;
            group.position.y = position.y;
            group.position.z = position.z;

            return group;
        }

        // Draw a camera
        var drawCamera = (position, rotation, fov) => {
            // カメラ位置にコーンを置く（説明用）
            const focalLength = 0.5
            const half_v = Math.tan(fov/2 * Math.PI/180) * focalLength;
            const half_h = half_v * film35mm_w / film35mm_h;
            var points = [
                new THREE.Vector3( -half_h, -half_v, 0 ),
                new THREE.Vector3( -half_h, half_v, 0 ),
                new THREE.Vector3( half_h, half_v, 0 ),
                new THREE.Vector3( half_h, -half_v, 0 ),
                new THREE.Vector3( 0, 0, focalLength )
            ];
            const cameraGeometry = new THREE.ConvexGeometry( points );
            const camObj = new THREE.Line( cameraGeometry, new THREE.LineBasicMaterial( { color: 0xffff00 } ) );
            const cameraPlaneGeometry = new THREE.PlaneGeometry( half_h*2, half_v*2 );
            const cameraPlaneMaterial = new THREE.MeshBasicMaterial( {color: 0xffff00, side: THREE.DoubleSide, transparent: true, opacity: 0.5} );
            const cameraPlane = new THREE.Mesh( cameraPlaneGeometry, cameraPlaneMaterial );
            cameraPlane.rotation.x = 0;

            // 上下がわからないので下に線を引く
            var underBarPoints = [
                new THREE.Vector3( -half_h, -half_v, 0 ),
                new THREE.Vector3( half_h, -half_v, 0 ),
            ]
            const underBarGeometry = new THREE.BufferGeometry().setFromPoints( underBarPoints );
            const underBarMaterial = new THREE.LineBasicMaterial({
                color: 0x00ffff
            });
            const underBarObj = new THREE.Line( underBarGeometry, underBarMaterial );

            var cameraAxes = new THREE.AxesHelper(0.5);
            cameraAxes.position.z = focalLength

            const group = new THREE.Group();
            group.add( camObj );
            group.add( underBarObj );
            group.add( cameraPlane );
            group.add( cameraAxes );

            group.position.x = position.x;
            group.position.y = position.y;
            group.position.z = position.z;
            group.rotation.x = rotation.x;
            group.rotation.y = rotation.y;
            group.rotation.z = rotation.z;

            return group;
        }

        // Create scene
        const scene = new THREE.Scene();

        var axes = new THREE.AxesHelper(3);
        axes.visible = param.showAxis;
        scene.add(axes);

        // Setup subjective camera view
        const renderer = new THREE.WebGLRenderer({antialias: true});
        renderer.setSize( window.innerWidth/2, window.innerHeight );
        var localview = document.getElementById("localview");
        localview.appendChild( renderer.domElement );

        camera.position.z = initialCameraZ;

        // Setup external camera view
        const overviewRenderer = new THREE.WebGLRenderer();
        overviewRenderer.setSize( window.innerWidth/2, window.innerHeight );
        var overview = document.getElementById("overview");
        overview.appendChild( overviewRenderer.domElement );

        const overviewCamera = new THREE.PerspectiveCamera( 280, window.innerWidth/2 / window.innerHeight, 0.1, 1000 );
        overviewCamera.position.x = 6;
        overviewCamera.position.y = 6;
        overviewCamera.position.z = 6;
        overviewCamera.up = new THREE.Vector3(0, -1, 0); // Y軸上向きに修正
        overviewCamera.lookAt(0, 0, 0);

        // Put a sphere in the scene
        const sphereObject = drawSphereObject(new THREE.Vector3(0, 0, 0), 2);
        scene.add(sphereObject);

        // Put a subjective camera in the scene
        var subjectiveCamera = drawCamera(new THREE.Vector3(0,0,1), new THREE.Vector2(0,0,0), param.fov);
        scene.add( subjectiveCamera );

        // Setup controls
        const controls = new THREE.OrbitControls( camera, renderer.domElement );
        console.log(camera.quaternion)
        
        // Setup overview controls
        const overviewControls = new THREE.OrbitControls( overviewCamera, overviewRenderer.domElement );
        overviewControls.enableDamping = true;
        overviewControls.dampingFactor = 0.05;

        const animate = function () {
            requestAnimationFrame( animate ); // Animation loop

            controls.update();
            overviewControls.update();
            var tempQuat = new THREE.Quaternion;
            tempQuat.copy(camera.quaternion);
            tempQuat = tempQuat.normalize();

            scene.remove( subjectiveCamera );
            subjectiveCamera = drawCamera(camera.position, camera.rotation, param.fov);
            scene.add( subjectiveCamera );
            subjectiveCamera.position = new THREE.Vector3
            subjectiveCamera.quaternion.copy(tempQuat)
            subjectiveCamera.position.x = camera.position.x;
            subjectiveCamera.position.y = camera.position.y;
            subjectiveCamera.position.z = camera.position.z;

            const dist = camera.position.distanceTo(new THREE.Vector3(0,0,0));

            zoomText.innerHTML = "Camera (x,y,z)=("+camera.position.x.toFixed(2)+", "+camera.position.y.toFixed(2)+", "+camera.position.z.toFixed(2)+"), dist="+dist.toFixed(2)+", zoom="+String(camera.zoom)+", FOV="+String(camera.fov);

            renderer.render( scene, camera );
            overviewRenderer.render( scene, overviewCamera );
        };

        // Handle window resize
        window.addEventListener('resize', function() {
            // Update camera aspect ratio
            camera.aspect = window.innerWidth / 2 / window.innerHeight;
            camera.updateProjectionMatrix();
            
            // Update overview camera aspect ratio
            overviewCamera.aspect = window.innerWidth / 2 / window.innerHeight;
            overviewCamera.updateProjectionMatrix();
            
            // Update renderer sizes
            renderer.setSize(window.innerWidth / 2, window.innerHeight);
            overviewRenderer.setSize(window.innerWidth / 2, window.innerHeight);
        });

        // Start animation
        animate();
    </script>
</body>